在 32 位的操作系统中，一个指针长度是 4 字节
在 64 位的操作系统中，一个指针长度是 8 字节

只要是声明的是基类的指针，即使实际指向的实例是派生类的，也不会调用派生类的析构方法。
A* c = new B[2];
    delete[] c;

只要是声明的是派生类的指针，并且实际指向的实例是派生类的，会先调用派生类的析构方法，然后级联调用父类的析构方法。
B* c = new B[2];
    delete[] c;


二叉树总节点数目为N,有 N=N0+N1+N2---(公式1)；二叉树度数总和为0*N0+1*N1+2*N2 


n0 表示叶结点的个数、n2 表示度为2 的非叶结点的个数
结点的度：结点子树的个数
所以结点总数比度数多1,则有N-1=N1+2*N2(公式2)；  N0=N2+1

DNS用的UDP，其他一些P2P应用，如迅雷，BT、qq等也会用UDP来传输。
一般用的都是TCP，比如HTTP, SSL ，FTP, SMTP, POP3, IMAP等等很多。

1、因为ping的话 后面跟的是地址，所以要先将域名转换为ip地址，即用到了DNS

DNS就是将域名翻译成IP地址。

2、获取到ip地址后，在数据链路层是根据MAC地址传输的，所以要用到ARP解析服务（IP地址到物理地址的解析），获取到MAC地址

3、ping功能是测试另一台主机是否可达，程序发送一份ICMP回显请求给目标主机，并等待返回ICMP回显应答，（ICMP主要是用于ip主机、路由器之间传递控制信息，控制信息是指网络通不通，主机是否科大）
4、TCP的话，不涉及数据传输，不会用到


#pragma pack(push) //保存对齐状态
#pragma pack(4)//设定为4字节对齐
struct test
{
char m1;
double m4;
int m3;
};
#pragma pack(pop)//恢复对齐状态
以上结构体的大小为16，下面分析其存储情况，首先为m1分配空间，其偏移量为0，满足我们自己设定的对齐方式（4字节对齐），m1大小为1个字节。接着开始为m4分配空间，这时其偏移量为1，需要补足3个字节，这样使偏移量满足为n=4的倍数（因为sizeof(double)大于4）,m4占用8个字节。接着为m3分配空间，这时其偏移量为12，满足为4的倍数，m3占用4个字节。这时已经为所有成员变量分配了空间，共分配了16个字节，满足为n的倍数。如果把上面的#pragma pack(4)改为#pragma pack(8)，那么我们可以得到结构的大小为24。


#define Mul(x,y) ++x*++y

void main()
{
	int a = 1;
	int b = 2;
	int c = 3;

	printf("%d", Mul(a + b, b + c));
}
 结果应该是++a + ++b*++b + c


printf输入从右向左，输出从左向右


前:根左右 中:左根右 后:左右根





bitset<64>的size操作返回bitset对象中二进制位中1的个数，返回值类型是size_t


先调用empty()函数判断list是否为空，再调用front()和back()函数。


list不可以随机存取元素，所以不支持at.(pos)函数与[]操作符。It++(ok) it+5(err)


list.rbegin();         //返回容器中倒数第一个元素的迭代器。
 list.rend();         //返回容器中倒数最后一个元素(第一个)的后面的迭代器。

for (list<int>::reverse_iterator rit=lstInt.rbegin(); rit!=lstInt.rend(); ++rit)

{

cout << *rit;

cout << " ";

}
反向输出


list(const list &lst);  //拷贝构造函数。
list<int> lstIntD(lstIntA); //1 3 5 7 9     这是在初始化
IstIntA与数组类似（？），代表了首地址（？）

 list& operator=(const list &lst); //重载等号操作符

list.clear(); //移除容器的所有数据
list.erase(beg,end);  //删除[beg,end)区间的数据，返回下一个数据的位置
list.remove(elem);   //删除容器中所有与elem值匹配的元素。
list.erase(pos);    //删除pos位置的数据，返回下一个数据的位置。
list.reverse();  

  if(*it == 3)

   {

        it  =  lstInt.erase(it); 


auto：C++11标准引入的类型说明符，编译器通过初始值来推算变量的类型、






bool Comp(const int &a,const int &b)
{
    return a>b;
}
调用时:sort(vec.begin(),vec.end(),Comp)，这样就降序排序




平衡二叉树 又称为  AVL树






Pair<map<int, string>::iterator, bool> Insert_Pair;  
Insert_Pair = mapStudent.insert(map<int, string>::value_type (1, "student_one"));  
Insert_Pair.second == true

它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。










假设我们用的电脑是单核的，cpu同时只能执行一个进程。进程由程序，数据集，进程控制块三部分组成

程序用来描述进程哪些功能以及如何完成；数据集是程序执行过程中所使用的资源；进程控制块用来保存程序运行的状态

一个进程中可以开多个线程。  因为一个程序中，线程共享一套数据，如果都做成进程，每个进程独占一块内存，那这套数据就要复制好几份给每个程序



遍历是二叉树上最重要的运算之一，是二叉树上进行其它运算之基础

nullptr在C++11中就是代表空指针，不能被转换成数字。   
在编译器进行解释程序时，NULL会被直接解释成0，而不是空指针


二叉搜索树是左子树<根节点<右子树（中序遍历）


set主要不同之处在于插入元素时具有自动排序功能的


哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
如果使用数组，那么下标从0开始，父节点是i，则左子树是2*i+1，右子树是2*i+2。如果子节点是i，则父节点是（i-1)/2


完全二叉树(Complete Binary Tree)
若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数

所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度


起始地址为上一地址的结束


索引顺序查找又称为分块查找，是介于顺序查找和二分查找之间的一种查找方法


&a表示一个指向大小为5数组的指针，那么(&a+1)就是表示一个指向大小为5的下一个数组的指针



puts（）输出一个字符串，遇到'\0'结束，putchar（）输出单个字符
while(*p++); //此句执行结束，p指向的是字符串末尾的"\0"
串的长度应该是指字符串中所含字符的个数，从开始地址计数字符，遇'\0'停止计数。注意转义字符

概念解释：广义表L=(A,B,C),表头是A，表尾是（B,C)，这是定义。


tail()表示取字符串的尾部，head()表示取字符串的头，concat()表示字符串拼接。


KMP算法下，长为n的字符串中匹配长度为m的子串（m为模式串）的复杂度为O(M+N)，简单匹配算法的时间复杂度为O(m*n)
这里指linux的命令grep。而在c++的string类中，find()函数也有找匹配的字符串的功能







p1和p2都指向常量字符串，在常量区，所以不能对其进行操作；改为数组即可，但是用字符串初始化数组时要记得将数组长度加1
char *p1 = ”123”, *p2 = ”ABC”, str[50] = “xyz”;  有错误
strcpy(str + 2, strcat(p1, p2));

字符串“123”本身在常量区，是常量不能进行更改，strcat是在123后面加字符，所以出错



堆排序首先将堆顶元素与最后一个元素互换



串的数据元素是一个字符,它只有8位二进制数,


这里考查转义字符，注意 \\ 表示字符 \
\123表示字符 {
\t 表示制表符
这些都是一个字符。

char *name;
name=(char*)malloc(50);      //此时name已经指向一个刚刚分配的地址空间。
malloc为指针分配空间



字符串最后以 ’ \0 ’ 结束
strcpy(s1,s2)这个函数是把s2字符串拷贝到s1这个字符串，同时也把s2的 '\0' 拷过去，所以覆盖了s1的所有字符

C语言的标识符不能以数字开头

字符串的两种最基本的存储方式是顺序存储方式和链接存储方式


链表中指针指向谁就把谁的地址赋给指针。p->next=HL->next;HL->next=p;、


递归是栈实现的



a*：关键：

如果它已经在开启列表中，用G值为参考检查新的路径是否更好。更低的G值意味着更好的路径。如果是这样，就把这一格的父节点改成当前格，并且重新计算这一格的G和F值。如果你保持你的开启列表按F值排序，改变之后你可能需要重新对开启列表排序。


堆的父节点的索引位置等于其叶子节点的索引位置除以2.   index=n/2
2 * index < n  表示父节点有左右儿子




键值对====结构体



memset是计算机中C/C++语言函数。将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定

用于数组初始化 

void *memset(void *s, int ch, size_t n);
函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。
它是对较大的结构体或数组进行清零操作的一种最快方法



用一个一维数组存放图中所有顶点数据；用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵




函数原型：void *memcpy(void *dest, const void *src, size_t n)
功能：将指针src指向的内存空间的n个字节复制到dest指针指向的内存空间
参数：src 为原内容内存的起始地址，dest为复制到目标地址的起始地址
返回值：目标dest内存的起始地址


最少节点数n如以斐波那契数列可以用数学归纳法证明
N(0)=1(表示AVLTree高度为0的节点总数
N(1=2 表示AVLTree高度为1的节点总数
N(2)=4（表示AVLTree高度为2的节点总数
N(h)=N(h?1)+N(h?2)+1 表示 AVL Tree 高度为h的节点总数


Huffman编码的构造方法：先合并最小频率的2个字符对应的子树，计算合并后的子树的频率；重新排序各个子树；对上述排序后的子树序列进行合并；重复上述过程，将全部结点合并成1棵完整的二叉树；对二叉树中的边赋予0、1，得到各字符的变长编码。


优先队列
priority_queue<long long int, vector<long long int>, greater<long long int> > q;  


如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树的代价是指生成树上各边权的总和，在G的所有生成树中，耗费最小的生成树称为G的最小生成树。例如在设计通信网络时，用图的顶点表示城市，用边(v,w)的权c[v][w]表示建立城市v和城市w之间的通信线路所需的费用，最小生成树给出建立通信网络的最经济方案。


单链表插入时间应该是O（1），但要维持有序状态，就应该从头结点开始逐个进行比较扫描，最坏O（N）


带尾指针的单向链表：插入可以，但是删除无法完成，因为p需要前移，但是单向链表无法得到前一个节点。
带尾指针的双向链表：插入和删除都很简单。
带尾指针的单向循环链表：插入很简单，删除则需要遍历整个链表，比较费时。
带头指针的双向循环链表：插入和删除都很简单。
重点在于避免遍历整个链表

值为空的链域个数为n+1个，为非空的个数为n-1。


有n个元素的序列，若使用筛选法建堆，则从位置为n/2取下整的元素开始建堆

堆排序的时间复杂度为nlogn,构建堆的时间复杂度为o(n),重建堆的时间复杂度为nlogn





printf("%d,%d\n",*p,*(++p));
先计算*(++p),*p=arr[2],在计算*p=arr[2].原因prinf从右到左编译，从左到右输出

类中变量赋值顺序是变量声明顺序，所以赋值时先执行a(b)，再执行b(i+1)。a赋值为随机数 

64位机下，指针占8个字节，所以sizeof(B)为8.getSize()是一个函数，数组名作为函数的参数退化为指针，所以size3也为8 
虚函数会占用内存空间，这边64位系统，则占用8Byte。 




快排：
只需要掌握一点就可以解出这个问题：每趟排序就有一个元素排在了最终的位置上。那么就是说，第n趟结束，至少有n个元素已经排在了最终的位置上。

2,3,4,5,6,7,9
4,2,3,5,7,6,9
有两个满足。

字符变量c1被赋值为'C'+'8'－'3',即ASSCII码的运算,67十54－49=72,即H

  最大和最小分别是01111000 10000111,那么10000111的原码是11111001为-121



((int *)0)+4是“指针+整数”结构，这时的整数就被解释为元素个数，1个元素4字节，4个元素自然是16字节，且这个16被自动提升为(int *)0的类型，亦即int *指针类型；