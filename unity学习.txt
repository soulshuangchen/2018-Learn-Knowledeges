任务8中  小球速度过快 堆积到一起  如何解决？
任务18中  当视角不接近cube时，无法放置炮台，拉近视角可以，为什么?
任务30中  路线为什么颜色会变化？？
任务37中  6.38分 启用禁用画布除了第一次有动画效果 其余都没有 为什么  而且完整作下来后报错

动画只播第一次（出现的那次，消失的动画都没有），而后所有动画都没有，可以实现切换（enable==false）为什么
要不就是第一次（出现动画没有，消失的动画出现），而后所有动画都没有，连切换都无法实现


橙色的待机动画是初始状态，其他状态都需要从这里出发，也都能回到这里

射线检测  


点击后字消失，但没有播放消失动画。当再次点击本应出现“出现动画”，却先出现消失动画再出现出现动画

左右x方向  上下y方向  前后z方向


需要增加的东西：
第一部分：（1）敌人提供的金钱数（2）攻击范围的显示（2）激光的减速（3）主动攻击的设置（4）杂物的设置（5）升级上面把金钱显示出来，摧毁上面把金钱显示出来（6）大本营存在血量，不会像现在这样进入一个就死亡（7）敌人有伤害，可对大本营造成伤害

（1）大本营可升级，血量、攻击（力、范围）等参数（2）通关给宝石，每次通过后进入部队升级界面，通过宝石提升部队属性，提供技能树，部队花费的金钱数始终不变

（1）多关卡的设置（类似rouglike）地图不能随机（所有rouglike类游戏只有物品是随机的（随机掉落，随机出现在某种形式），地图没有（印象中是这样））（2）UI技能界面，图标，效果，有读条时间，通过攻击敌人攒能量（暂时想法）（3）UI陷阱界面，图标，效果（4）释放部队，阻挡敌人，敌人会攻击部队，直到部队消失


（1）产生金钱的效果（2）鼠标放在上面金钱的拾取（金钱消失，有金色效果进入money数字中）（3）炮塔的形式，只能攻击地面，只能攻击天空，都能够攻击（4）敌人的属性，地面/天空（5）判断炮塔能攻击什么敌人

（1）敌人的进化，随着关卡的提高，敌人属性上升，并且可能具有技能，可以攻击你的部队（2）存在英雄单位（敌我均有），其属性爆炸，并且有光环效果（3）无视地形的敌人？

（1）存在福利关卡，敌人无攻击，部队可攻击但不可阻拦，

（1）炮塔升级的支线，不止升级一次，可以多次，并且可以有至少两个方向进行进化（2）炮塔的进化与关卡有关，只有打通某一关，或打到某一关，才能开启炮塔的某个进化，部队也是一样的（类似SC2）

































在JavaScript

计算机语言中的var：Pascal: var 在Pascal 作为程序的保留字，用于定义变量。 如：var a:integer；（定义变量a，类型为整数） var u:array[1..100]of integer；（定义数组u，下标由1至100，数组单元类型为整数）

⒈在一个过程级中（即位于function的定义范围内，无论是函数，还是类）的任何地方，包括在一个区块里（for,while,if……），定义变量时，使用var定义，则此变量只在这个过程级内起作用，反之为全局变量。

⒉在过程级外定义变量时，无论是否忽略var，都将定义一个全局变量

从这点看来，JS和其他语言有不一样的地方，变量的范围不以“{}”作为边界，而是以"function(){}"为边界，而且在过程内可以很轻松的定义全局变量。如果不注意这个问题的话，是很容易产生不可预知的错误的

对于使用var，我的建议是要养成好的使用习惯：
⒈在程序的开头，统一定义全局变量；
⒉所有的变量在定义时都要加上var；
⒊尽量不要在不同的过程中使用相同的变量名。









prefab：预制件。  即做好的一些模块，可以将这些模块直接添加到场景中，也可以向这些prefab添加Js、C#等脚本文件去“修饰”这些模块

Graphics 类是所有图形上下文的抽象基类


voxelinfo 包含体素信息












































collider 碰撞器


基础操作：


1.创建脚本时，文件名和类名要一致，若文件名有错需要修改，经过修改后，程序中的类名需要手动修改以使其和文件名保持一致。

2.记日志：Debug.Log()

3.直接写一个小数0.2，默认类型为double而不是float，若为float。则需要0.2f

4.多个数据类型运算，返回的结果类型是数据类型大的

5.加法“+”可以用来直接连接两个字符串（拼接）

6.在Unity中，数组声明与定义与c++不同。c++中，int a[10]={};,c#中 int []a={};,数组初始化与声明在一起，且不能定义数组大小，不能在变量声明中指定数组大小。访问数组中的元素与c++方式一致

数组  类型[] 数组名 = {数组值}。

或者  int[] h = new int [n];这样可以确定数组大小

7.for循环动态得到数组长:数组名.Length,返回数组长度，例如：h.Length

8.类名首字母大写，类和文件名保持一 致

9.枚举： 定义（与方法类似）：enum RoleType{Mag,Soldier,Wizard} (逗号隔开)
在方法中调用： RoleType rt = RoleType.Mag; rt = RoleType.Soldier;

10. Vector3类型参数，声明位置pos。在调用时，需要new一个新的vector3变量
例如： CreateEnemy(new Vector3(1,1,1));

11.类实现： Enemy enemy1 = new Enemy();,貌似没有像c++一样，仅Enemy enemy1这样就实现了实例化

12.GameObject类型的变量（指针？？？），这个类型是直接赋值一个游戏物体，在Inspector中显示

13.在程序运行时，start方法仅运行一次。

14.Update is called once per frame  每帧执行一次 1s=50帧

15.脚本中变量的初始值是inspector中的值，程序定义的初值只在一开始的时候显示在inspector中，后续再改动inspector中的值不会变（需要变从unity界面调整），后面变量初始值与程序中定义的值无关。（当代码里面的初始值与inspector中的初始值不符时）

16.GameObject.Destroy(children[i].gameobject)
GameObject中的Destroy方法，用来销毁children[i]这个transform组件中的gameobject游戏物体

Transform[] children = transfrom.GetComponentsInChildren<Transform>[];这样children数组里面会包含transform本身以及其子物体
if（children[i]!=transform）

17.foreach遍历。
foreach（Transform t in children）{}//t代表children数组里面的子内容，类型可以是其他的如Collider

18.组件的获取（访问）。尖括号中跟的是组件的类型
例如：Transform t = GetComponent<Transform>（）；获取物体本身
	public Learn02_Player2 learn02;//可以把自己写的脚本拖拽赋值到另一个脚本上

GetComponent不论组件是否被禁用（处于何状态），都能获得组件内容

19.组件的禁用与激活。
禁用：BoxCollider collider = GetComponent<BoxCollider>();//得到方体碰撞器组件
	collider.enabled = false;
即使组件被禁用，组件里面的方法（或者叫函数）依然可以被调用，去使用。

20.获取游戏物体的方式。
1.直接public拖拽。举例：  游戏物体：GameObject。 组件：Camera

2.transfrom.Find（“子物体的路径”），“子物体的路径”这个东西是一个字符串，只能寻找子物体
例如Learn下的GameObject（1）下的GameObject，则为
transfrom.Find（“GameObject（1）/GameObject”）

3.GameObject mainCameraGo = Gameobject.Find("要找的物体的名字")

4.GameObject player = GameObject.FindWithTag("Player")//根据标签来查找，标签设置在unity界面