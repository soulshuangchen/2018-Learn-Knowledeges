划分子网的原理是从主机位中“借”位作为子网位。对于C类地址，主机位有8位。
若每个子网最多15台主机，则主机位至少需要5位(24-2＜15＜25-2)，因此子网位最多有3位，而23＜9，因此无法满足上述要求。



















1： 链路层--网络层--传输层--应用层
    物理层--数据链路层--网络层--传输层--会话层--表示层--应用层
2： 端口：用来区分 进程（标记进程）。  通过端口号实现进程间的通信

3：ip地址：
 
A类：0xxxxxxx（网络号7位） 主机号24位
B类：10xxxxxx xxxxxxxx（网络号14位）  主机号16位  127.
C类：110xxxxx xxxxxxxx xxxxxxxx（网络号21位） 主机号8位     前面的相同，即在同一个网段中
D类：1110 28位随意
E类：11110 27位随意

最后一个为0，表示网络号； 最后一个为255，表示广播地址

4：socket套接字：通过网络使进程之间通信  （单个电脑上进程间通讯方式：管道、队列、内存映射）

创建socket对象： s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)   完成tcp通信  慢、稳定
                固定写法，前一个表示IPv4协议,
               s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)   完成udp通信   快、丢数据

#桥接模式？？？（必须改为吗？）
from socket import *
#1.创建套接字
updSocket = socket(AF_INET,SOCK_DGRAM)
#2.准备接收方的地址
sendAddr = ('192.168.1.103',8080)       ip地址,端口号
#3.从键盘获取数据
sendData = raw_input("请输入要发送的数据")
#4.发送数据到指定的电脑上
udpSocket.sendto(b“sendData”,sendAddr)
#5.关闭套接字
udpSocket.close()

5： 使用udp发送的数据，在每一次的发送中都需要写上接收方的ip和port
    在同一个OS中，端口不允许相同。即如果某个端口已经被使用了，那么在这个进程释放这个端口之前，其他进程不能使用这个端口。
    因为：端口是用来区分一个进程的，如果相同，那么就不能把数据发送给正确的进程。


6：udp绑定信息：  接收端绑定端口号   
udpSocket.bind(("",port))
bindAddr = （'',port） #IP一般不用写，表示本机任何一个ip


一般而言：bind的是服务器


接收：recvData = udpSocket.recvfrom(num);  num表示本次接收的最大字节数，一般为1024 
套接字可收可发，而且这个过程同时运行。  网络是全双工的

recvData是一个元组
recvData[0]表示接收到的数据（str），recvData[1]表示接收到的信息,即对方的ip和端口号，这也是一个元祖（str，num ）


7：SendData = input（“”）   #从键盘获取信息
udpSocket.sendto(sendData.encode("utf-8"),(destIp,destPort))
解码：content.decode（“编码方式”）  例如：utf-8，gb2312等等
python中：a=（num,‘str’）      b,c=a  意味着：b=a.[0](大意上是这样的)  c=a.[1]


8： python封装： if __name__ == "__main__":  main()

9： 多线程完成聊天：（多线程完成）
from threading import Thread
from socket import *

#1.收数据，然后打印
def recvData():
	while True:
		recvInfo = udpSocket.recvfrom(1024)
		print(">>%s:%s"%(str(recvInfo[1]),recvInfo[0].decode("gb2312")))
#2.检测键盘，发数据
def sendData（）：
	while True:
		sendInfo = input("<<")
		udpSocket.sendto(sendInfo.encode("gb2312"),(destIp,destPort))

udpSocket = None(存储对象)
destIp = ""
destPort = 0

def main（）：

	global udpSocket
	global destIp
	global destPort

	destIp = input（"对方的ip："）
	destPort = int(input（"对方的port："）)

	udpSocket = socket(AF_INET,SOCK_DGRAM)
	udpSocket.bind("",1234)

	tr = Thread（target = recvData）
	ts = Thread（target = sendData）

	tr.start()
	ts.start()

	tr.join()
	ts.join()

if __name__ == "__main__":
	main（）




11: TFTP下载： client：客户端  server:服务器   c/s架构
     b/s架构：浏览器/服务器架构  browser
     服务器： 给他人数据    客户端：从他人那接收数据

	TFTP服务器默认端口为69 
     三次握手：1.客户端发送读写请求到服务器（请求文件）  2.服务器发送给客户端文件（每次发送的数据包有范围），若文件过大，则分成许多部分，一点一点的传递文件     3. 为了保证数据真正的被客户端接收，客户端接收数据后，再发一条消息给服务器确认受到数据
 
     如果接受到的数据总长度小于516，那么意味着数据发送完毕


构造下载请求数据：cmd_buf = struct.pack("!H8sb5sb",1,"test.jpg",0,"octet",0)  (数据格式)
！表示大端模式，H占两个字节==1，8s == "test.jpg",b==0,5s==octet,b==0

大端、小端： 所有多字节组成的数据，在网络上都要用大端来进行发送。  
大：高位数据存到低地址上    小：低位数据存到低地址上

解包(解服务器发送给客户端的数据)：cmdTuple = struct.unpack("!HH",recvData[:4])   返回值是一个元组，第一个元素是操作码，第二个元素是数据序号


12：udp广播（tcp没有）：   udp:用户数据包协议
s.setsockopt(socket.SOL_SOCKET.socket.SO_BROADCAST,1)   这就能进行广播了（固定写法）
允许发送广播数据：  192.168.1.0 》》 网络号     192.168.1.255 》》广播地址

<broadcast> 会自动识别当前的广播地址. dest = ('<broadcast>',7788)==('192.168.1.255',7788)

13:tcp:传输控制协议。（socket创建出来的套接字，默认是主动套接字）    web服务器都是使用tcp
HTTP:用的就是TCP协议

TCP服务端：listen：监听， 将主动套接字变为被动套接字

TCP客户端：connect（）方法：与服务端建立连接（TCP三次握手）



服务器代码编写：

serverSocket.listen(num) num表示最多有num个客户端可以同一时刻发数据（？？？）
serverSocket.accept()  返回值是一个元组（newSocket，clientAddr）
分别表示：新的客户端，新的客户端的ip以及port

newSocket用来为这个客户端服务
serverSocket就可以继续专门等待其他新客户端的链接 

所以： recvData = newSocket.recv（1024）


14：客户端代码编写：1.创建套接字 2.connect链接 3.通过send发送数据（不通过sendto）
tcp客户端已经连接好了服务器，所以在以后的数据发送中，不需要填写对方的ip和port--》打电话――
udp在发送数据的时候，因为没有之前的连接，所以需要在梅西的发送中，都要填写接收方的ip和port――写信

15：一般而言：bind的是服务器（TCP），有listen一定是服务器。  
如果接收到的客户端发送的数据长度为0，那么意味着客户端通过调用close下线

16：网络号：ip地址与网络掩码按位与操作
网络掩码：A：255.0.0.0  B：255.255.0.0  C：255.255.255.0

一根网线插在两台电脑，两台电脑在同一网络号下，电脑间才能相互通信
hub：集线器

17：ping就是icmp协议     arp协议包:获取Mac地址号(网卡号) ,根据ip找mac地址
	rarp：根据mac地址找ip
链路层添加MAC地址        网络层判断目的ip地址

18：路由器：链接不同的网络，使他们之间能够通信。
19：mac地址，在两个设备之间通信时在变化。 而ip地址，在整个通信过程中都不会发生任何变化

20：dhcp服务器：自动分配ip地址。
访问百度：
1.先要解析出baidu.com对应的ip地址
	1.1先知道默认网关的mac
		1.1.1使用arp获取默认网关的mac地址
	1.2组织数据，发送给默认网关（ip还是dns服务器的ip，但是mac地址是默认网关的mac地址）
	1.3默认网关拥有转发数据的能力，把数据转发给路由器
	1.4路由器根据自己的路由协议，来选择一个合适的较快路径，转发数据给目的网关
	1.5目的网关（dns服务器所在的网关），把数据转发给dns服务器
	1.6dns服务器查询解析出baidu.com(域名)对应的IP地址，并发它原路返回，请求这个域名的client
2.得到了baidu.com对应的IP地址后，会发送tcp的3次握手，进行连接
3.使用http协议发送请求数据给web服务器
4.web服务器收到数据请求后，通过查询自己的服务器得到相应的结果，原路返回给浏览器
5.浏览器接收到数据后，通过浏览器自己的渲染功能来显示这个网页
6.浏览器关闭tcp连接，即4次挥手

21：dns==upd协议
3次握手：1.发送SYN 2.发送SYN+ack 3.发送ack     数据： 1.发送数据  2.返回一个ack
4次挥手：client：1.使用socket.close()关闭socket，发送数据给服务端 2.服务器发送确认收到的消息
	
recv解堵塞，并且recvData接收到的数据为0，表明对方下线

server：3.服务端使用socket.close()关闭newsocket，发送数据给客户端 4.客户端发送确认收到消息

浏览器收到服务器的数据后，立马调用close。 如果不调用close，该端口就不能再一次使用
4次挥手： 1.FIN+ACK(真正影响的是FIN) 

22：tcp的长连接：例如在线看电影。在一次三次握手的前提下，不断地把一串数据发送，最终调用一次4次挥手
  tcp短连接：例如打开一个网页。多次三次握手4次挥手，每次时发送1个数据，最终发送完一串数据 

23：DNS协议（服务器 ，底层udp协议）就是用来解析域名的协议。一个服务器可以有多个域名

24：netstat -t ：查看当前已经连接好的tcp服务器

25：TTL：确认经过路由器的个数
2MSL：一个数据包在网络上的最长存活时间

26：listen的参数：linux中无所谓
27：三次握手的第一部分为半链接

ddos攻击：tcp半链接攻击：效果就是服务器TCP连接资源耗尽，停止响应正常的TCP连接请求
arp攻击：中间人攻击 

28：如果serSocket不小心被close了，那么意味着：不能再接收新的客户端的连接
    如果newSocket被close了，那么意味着：这个套接字就不能再使用recv和send来收发数据了

29： serSocket.setblocking(False)  让这个socket变为非堵塞

30：select：
inputs = [server,sys.stdin]

while True:
#使用select函数，阻塞等待
	readable,writeable,exceptional = select.select(inputs,[],[])

for sock in readable:
#监听到有新的连接
#在select去检测inputs这个列表中的时候，所检测出来的所有可以进行接收数据的套接字
	if sock == server: 
		conn,addr = server.accept()
		#select监听的socket:
		inputs.append(conn)

31： s.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1)  #设置可以重复使用绑定的信息	

32：文件描述符就是这些数字:sys.stdin.fileno()=0;sys.stdout.fileno()=1;sys.stderr.fileno()=2
     fd


epoll_list = epoll.poll() #用来检测当前哪些套接字可以收，哪些可以写，哪些出现了异常
#epoll进行fd扫描的地方 -- 未指定超时时间则为阻塞等待

#如果是socket创建的套接字被激活  （对上面检测出来的套接字进行收发数据处理）
if fd==s.fileno():
	conn,addr=s.accept()

	#将conn和addr信息分别保存起来
	connections[conn,fileno()] = conn
	addresses[conn,fileno()] = addr

	#向epoll中注册、连接socket的可读事件
	epoll.register(conn.fileno(),select.EPOLLIN | select.EPOLLET)    epoll版服务器


计算密集型：需要占用大量的cpu资源
 
33：协成：微线程。线程里面的是协成(IO密集型--需要网络功能,大量的时间都在等待网络数据的到来)

一个函数里有yield关键字，那么这个函数就被叫做生成器（协成底层是生成器）  
生成器的值是yeild的结果（yield暂停当前函数，c.next使yield继续向下执行）（？？？？？？？？）

34：
应用层：解决要传递什么数据
传输层：解决如何传递数据   选择udp还是tcp 可以理解为快递公司  （）
网络层：ip 可以理解为地理位置坐标
链路层：具体的传输工具

35：                客户端                        服务器
               So =socket.socket()           Socket = socket.socket()
               So.connect()                  Socket.bind()
		                             Socket.listen()
                                             cli_so = Socket.accept()(针对于客户端的socket)
               So.send()    (sendto udp)     So.send()
               So.recv()    (recvfrom udp)   So.recv()

36：应用层协议（对应于不同场合有不同的协议）：
ftp：文件传输  ssh：远程连接   smtp、pop3  http  TELNET  nfs  这些协议导致传输格式不一样

37：HTML:超文本标记语言。   浏览器的作用就是解析字符串。其内核（引擎）就是解析字符串的算法

38：HTTP：超文本传输协议  

客户端发送（请求的报文格式）：

1. ：HTTP请求方式：GET（客户端想要请求资源，获取数据）、POST（修改数据）、PUT（使浏览器保存数据，上传）、DELETE（删除）、OPTION（询问服务器的某种支持特性）、HEAD（返回报文头）


2.：/代表请求的具体的资源是谁
4：HTTP/1.1:HTTP的协议版本  （1、2、4是起始行）
3.:请求头：包含一个键：一个值（在请求方式下面）

服务器响应：
1.：状态码（status code）：200 OK。2开头的表示执行成功 4代表用户端请求错误 5代表服务器错误
2：响应头，也是键值对的形式，用：隔开 

39：URI:URL:真正的网址是/前面的内容，位置：第一个/后面的内容，/s是页面，后面的是要查的内容      URN：名字。  

查询字符串（Query String）：从？开始的后面的玩意        
格式： ？key1=value1&key2=value2&key3=value3  （大小有限制）

HTTP无状态：一次连接请求完，服务器socket就会断掉。下一次请求又会重新开一个新的socket，新的跟上一次的没有关系






新：

1.TTL：数据包在网络上经过的路由器的最大值。 

最大值128，每经过一个路径（路由器），ttl值减1。 也就是说经过了一次转换关系
路由器接收到的数据包如果TTL值为0，则直接扔掉该数据包，而不会转发。

经过的路由器越多，传输速度越慢


2. MSL: 一个数据包在网络上最长存活的时间   1~2min 
   2MSL：客户端time_wait到close间的时间
在2msl的时间内会收到服务器端发送的第二次请求（挥手阶段）

3. listen（服务器端）的队列长度：   listen(5)
127.0.0.1： 本地ip
三次握手的第一部分为半链接。       


半链接和已连接的和为5
队列的大小：在没accept接收之前，最多有5个服务器能够进行连接（同一时刻访问），剩下的就需要进行等待

4.网络攻击：
tco半链接攻击： 客户端不停的发syn，但是不发送ack确认接收（确认接收后，半链接中的客户端信息才到全连接中），那么在半链接的队列中就会存在很多信息，导致正常用户无法访问网站
SYN Flood(SYN洪水)，这是种典型的ddos（拒绝服务）攻击 。


dns攻击（udp攻击）：钓鱼网站。  
dns劫持：域名服务器对其区域内的用户解析请求负责，一些域名服务器故意更改一些域名的解析结果，将用户指向一个错误的目标地址。这叫做DNS劫持，用来组织用户访问特定网站，或将用户引导到广告页面。

dns欺骗：用假DNS应答来欺骗用户计算机，让其相信这个假的地址，并且抛弃真正的DNS应答


arp攻击：伪造数据包。中间人攻击  
例如：提供给客户端和服务器的数据包中的mac地址都是同一个。
告诉客户端：服务器的IP地址和自己的mac（物理）地址，将从服务器得到的数据发送给客户端
告诉服务器：客户端的IP地址和自己的mac地址，从服务器获得客户端想请求的数据，将数据保存在数据库

arp 255.255.255.255  攻击所有电脑  ？？



5.if len(recvData)<=0  说明客户端调用了close()

多进程就是实现多任务的一种方式    

listen(监听)变为被动套接字，通过try进行异常抛出，从而实现被动套接字关闭
try:
xx
finally:
serSocket.close()

newsocket被close，那么意味着：这个套接字就不能再使用recv和send来收发数据了



6.TCP 的流量控制与拥塞控制可以说是一体的。流量控制是通过滑动窗口实现的，拥塞避免主要包含以下2个内容：
（1）慢开始，拥塞避免
（2）快重传，快恢复


 所谓的流量控制就是让发送方的发送速率不要太快，让接收方来得及接受。利用滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。TCP的窗口单位是字节，不是报文段，发送方的发送窗口不能超过接收方给出的接收窗口的数值。

接收方的主机B进行了三次流量控制。第一次把窗口设置为rwind=300，第二次减小到rwind=100最后减到rwind=0，即不允许发送方再发送过数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止

假如，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwind=400的报文段，然而这个报文段在传送中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。


.TCP报文段发送时机的选择
     TCP豹纹短短发送时机主要有以下几种选择途径。
     1）TCP维持一个变量，它等于最大报文段长度MSS，只要缓存中存放的数据达到MSS字节就组装成一个TCP报文段发送出去。
     2）由发送方的应用程序指明要求发送报文段，即TCP支持的推送操作
     3）是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段发送出去。



拥塞控制：

在某段时间，若对网络中的某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变化，这种情况叫做拥塞。

网络拥塞往往是由许多因素引起的，简单的提高节点处理机的速度或者扩大结点缓存的存储空间并不能解决拥塞问题

例如：当某个结点缓存容量扩展到非常大，由于输出链路的容量和处理机的速度并未提高，因此在这队列中的绝大多数的分组在排队等待时间会大大增加，结果上层软件只好把他们进行重传。

只有各个部分平衡了，问题才会得到解决


拥塞控制和流量控制的差别：
     所谓拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能承受现有的网络负荷。
     流量控制往往指的是点对点通信量的控制，是个端到端的问题。流量控制所要做的就是控制发送端发送数据的速率，以便使接收端来得及接受。


拥塞控制设计
     拥塞控制是很难设计的，因为它是一个动态的问题，许多情况下，甚至正是拥塞控制机制本身成为引起网络性能恶化甚至死锁的原因。从控制理论的角度来看拥塞控制这个问题，可以分为开环控制和闭环控制两种方法。开环控制就是在设计网络时事先将有关拥塞发生的所有因素考虑周到，一旦系统运行起来就不能在中途改正。

     闭环控制是基于反馈环路的概念，包括如下措施：
     1）监测网路系统以便检测拥塞在何时何地发生
     2）把拥塞发生的信息传送到可采取行动的地方
     3）调整网络系统的行动以解决出现的问题。


4.拥塞控制方法
因特网建议标准RFC2581定义了进行拥塞控制的四种算法，即


慢开始（Slow-start)，拥塞避免（Congestion Avoidance)快重传（Fast Restrangsmit)和快回复（Fast Recovery）。

我们假定
     1）数据是单方向传送，而另外一个方向只传送确认
     2）接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。





--慢开始和拥塞避免
     发送报文段速率的确定，既要根据接收端的接收能力，又要从全局考虑不要使网络发生拥塞，这由接收窗口和拥塞窗口两个状态量确定。

接收端窗口（Reciver Window)又称通知窗口（Advertised Window),是接收端根据目前的接收缓存大小所许诺的最新窗口值，是来自接收端的流量控制。

拥塞窗口cwnd（Congestion Window)是发送端根据自己估计的网络拥塞程度而设置的窗口值，是来自发送端的流量控制。
     慢启动原理：
     1）当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞
     2）比较好的方法是试探一下，即从小到达逐渐增大发送端的拥塞控制窗口数值
     3）通常在刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段的MSS的数值。在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，当rwind足够大的时候，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量---慢开始门限ssthresh

     拥塞控制具体过程为：
     1）TCP连接初始化，将拥塞窗口设置为1
     2）执行慢开始算法，cwind按指数规律增长，直到cwind == ssthress开始执行拥塞避免算法，cwnd按线性规律增长
     3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行。


--快重传和快恢复

     一条TCP连接有时会因等待重传计时器的超时而空闲较长的时间，慢开始和拥塞避免无法很好的解决这类问题，因此提出了快重传和快恢复的拥塞控制方法。

     快重传算法并非取消了重传机制，只是在某些情况下更早的重传丢失的报文段（如果当发送端接收到三个重复的确认ACK时，则断定分组丢失，立即重传丢失的报文段，而不必等待重传计时器超时）。慢开始算法只是在TCP建立时才使用


     快恢复算法有以下两个要点：
     1）当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。
     2）由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，是拥塞窗口的线性增大。








7.UDP传输快，适合视频，直播之类的传输数据，但是容易丢失数据；TCP稳定，不会丢失数据，适合传输文字之类的（TCP稳定，不会丢失数据，但也是相对而言的）




UDP 便于 NAT 穿透

NAT穿越（NAT traversal）涉及TCP/IP网络中的一个常见问题，即在处于使用了NAT设备的私有TCP/IP网络中的主机之间建立连接的问题。


端口映射，其实就是常说的NAT地址转换的一种，其功能就是把在公网的地址转翻译成私有地址， 采用路由方式的ADSL宽带路由器拥有一个动态或固定的公网IP，ADSL直接接在HUB或交换机上，所有的电脑共享上网。
在局域网内部的任一PC或服务器上运行到内网穿透客户端，此时域名解析到的IP地址是局域网网关出口处的公网IP地址，再在网关处做端口映射指向监控设备即可。


网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机


网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）






1.TCP是基于不可靠的网络实现可靠的传输，肯定也会存在掉包的情况

2.TCP是一个“流”协议，一个完整的包可能被TCP拆分成多个包发送，也有可能把小的封装成大的发送，这就是TCP粘包和拆包问题。

3.如果通信中发现缺少数据或者丢包，那么，最大的可能在于程序发送的过程或者接收的过程出现问题。


例如服务端要给客户端发送大量数据，Send频率很高，那么就很有可能在Send环节出现错误（1.程序处理逻辑错误，2.多线程同步问题，3.缓冲区溢出等），如果没有对Send发送失败做处理，那么客户端收到的数据比理论要收到的数据少，就会造成丢数据，丢包现象。 



常用的解决方法有：拆包，加包头，发送组合包，如果是服务器端或者客户端掉线的话，通常采用心跳测试。
心跳测试：每隔一段时间向服务端发送数据包，为了节省资源通常发送空的数据包，如果不能发送成功说明Socket已经断开，这个时候就需要根据具体情况释放资源和重新连接。



粘包、拆包问题说明

假设客户端分别发送数据包D1和D2给服务端，由于服务端一次性读取到的字节数是不确定的，所以可能存在以下4种情况。

    1.服务端分2次读取到了两个独立的包，分别是D1,D2,没有粘包和拆包；
    2.服务端一次性接收了两个包，D1和D2粘在一起了，被成为TCP粘包;
    3.服务端分2次读取到了两个数据包，第一次读取到了完整的D1和D2包的部分内容,第二次读取到了D2包的剩余内容，这被称为拆包；
    4.服务端分2次读取到了两个数据包，第一次读取到了部分D1，第二次读取D1剩余的部分和完整的D2包；

如果此时服务端TCP接收滑动窗口非常小,而数据包D1和D2都很大，很有可能发送第五种可能，即服务端多次才能把D1和D2接收完全，期间多次发生拆包情况。
接收滑动窗：所谓滑动窗口协议，自己理解有两点：

1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；

2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”


粘包问题的解决策略

由于底层的TCP无法理解上层的业务逻辑，所以在底层是无法确保数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：

    1.消息定长，例如每个报文的大小为固定长度200字节,如果不够，空位补空格；
    2.在包尾增加回车换行符进行分割，例如FTP协议；
    3.将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路是消息头的第一个字段用int来表示消息的总长度；（我之前linux C开发，就用的这种）。
    4.更复杂的应用层协议；













 127.X.X.X网络保留做为环路自检地址，该地址表示任意主机本身，目的地址为环路自检地址的IP数据报永远不会出现在任何网络上。

32位全为1，即255.255.255.255表示整个TCP/IP网络的广播地址;32位全为0，即0.0.0.0表示本网络上的本主机。  










8.DNS域名系统:

当DNS客户机需要在程序中使用名称时，它会查询DNS服务器来解析该名称。客户机发送的每条查询信息包括三条信息：包括：指定的DNS域名，指定的查询类型，DNS域名的指定类别。基于UDP服务，端口53. 该应用一般不直接为用户使用，而是为其他应用服务，如HTTP，SMTP等在其中需要完成主机名到IP地址的转换。

9.

ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，
DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段，使用UDP协议工作。具体用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。


10.ARP是地址解析协议:

1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。
3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
广播发送ARP请求，单播发送ARP响应。



在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）。

网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户。



11.RARP协议:

RARP是逆地址解析协议，作用是完成硬件地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。工作流程：在网络中配置一台RARP服务器，里面保存着IP地址和MAC地址的映射关系，当无盘工作站启动后，就封装一个RARP数据包，里面有其MAC地址，然后广播到网络上去，当服务器收到请求包后，就查找对应的MAC地址的IP地址装入响应报文中发回给请求者。因为需要广播请求报文，因此RARP只能用于具有广播能力的网络。